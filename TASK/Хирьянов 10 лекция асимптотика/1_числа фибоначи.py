# Вступление

# Эта работа посвящена рассмотрению понятия асимптотической сложности алгоритмов на конкретных примерах.
# Грубо говоря, асимптотическая сложность алгоритма — это количество операций, из которых этот алгоритм состоит.
# В ходе работы вы напишете несколько различных алгоритмов, которые в силу различной вычислительной сложности
# будут выполняться за разное количество времени.

# Начало работы
# Эта работа выполняется при помощи **Jupyter Notebook** — интерактивной «тетрадки», которая позволяет хранить
# текст, код, графики и т.д.
# Первым делом подключим необходимые нам модули:
#     "import util",
#     "import matplotlib",
#     "import random",
#     "import math",
#     "%matplotlib inline"
# Мы не будем детально останавливаться на том, за что именно отвечают эти модули, поскольку к самой работе это
# имеет весьма опосредованное отношение.

# Задание №1: числа Фибоначчи",
# Напишите рекурсивную реализацию функции, вычисляющей числа Фибоначчи. Для этого допишите тело функции ниже:
def recursive_fib(n):
    if n < 2:
        return n
    return recursive_fib(n - 1) + recursive_fib(n - 2)

# Проверьте, что функция работает корректно:

assert recursive_fib(0) == 0
assert recursive_fib(1) == 1
assert recursive_fib(9) == 34

# Теперь напишите рекурсивную реализацию, но с использованием дополнительного массива в роли кэша,
# в котором хранятся уже вычисленные значения:

def recursive_fib_with_cache(n, cache=None):
    A = [0, 1]
    while len(A) < n + 1:
        A.append(0)
    if n <= 1:
        return n
    else:
        if A[n - 1] == 0:
            A[n - 1] = recursive_fib_with_cache(n - 1)

        if A[n - 2] == 0:
            A[n - 2] = recursive_fib_with_cache(n - 2)

        A[n] = A[n - 2] + A[n - 1]

        return A[n]

# Убедитесь, что функция работает корректно:

assert recursive_fib(0) == 0
assert recursive_fib(1) == 1
assert recursive_fib(9) == 34

# И, наконец, напишите нерекурсивную реализацию функции:

def fib(n):
    if n == 0:
        return 0
    A = [1, 1]
    while len(A) < n:
        A.append(0)
    for i in range(2, n):
        A[i] = A[i - 1] + A[i - 2]
    return A[-1]

# Проверьте правильность реализации:

assert recursive_fib(0) == 0
assert recursive_fib(1) == 1
assert recursive_fib(9) == 34

# А теперь давайте посмотрим на скорость работы написанных выше функций:

util.plot_fib_results(
    ('Рекурсивная реализация', recursive_fib),
    ('Рекурсивная реализация с кэшем', recursive_fib_with_cache),
    ('Реализация при помощи цикла', fib)
    )

# Можно видеть, что самой быстрой является реализация при помощи цикла.
# **Вопрос**: какова асимптотическая сложность реализованных алгоритмов?

