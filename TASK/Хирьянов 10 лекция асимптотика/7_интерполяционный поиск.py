# Задание №7: интерполяционный поиск

# Если кроме упорядоченности про массив известно, как именно возрастают (убывают) в нём элементы,
# то алгоритм двоичного поиска можно существенно улучшить. Вместо деления отрезка пополам можно
# выполнить интерполяцию и получить приблизительное положение элемента в массиве.
# Такая модификация будет называться *интерполяционным поиском*.
# Напишите реализацию алгоритма интерполяционного поиска, предполагая, что элементы в массиве возрастают линейно:
def interpolation_search(a, x):
    left = 0
    right = len(a) - 1
    while a[left] < x and x < a[right]:
        pos = left + int((x - a[left]) * (right - left) / (a[right] - a[left]))
        if a[pos] < x:
            left = pos + 1
        elif a[pos] > x:
            right = pos - 1
        else:
            return pos

    if a[left] == x:
        return left
    elif a[right] == x:
        return right
    else:
        return -1

# def interpolation_search_recursiv(arr, l, r, x):
#
#     if r >= l:
#         mid = l + ((x - arr[l])*(r-l)) // (arr[r] - arr[l])
#
#         if arr[mid] == x:
#             return mid
#
#         elif arr[mid] > x:
#             return interpolation_search_recursiv(arr, l, mid - 1, x)
#
#         else:
#             return interpolation_search_recursiv(arr, mid + 1, r, x)
#     else:
#
#         return -1



# Проверьте свою реализацию:

print(interpolation_search([1, 2, 3, 4, 5], 5)) #  == 4
print(interpolation_search([1, 2, 3, 4, 5], 3)) #  == 2
print(interpolation_search([1, 2, 3, 4, 5], 1)) #  == 0

# Сравните скорость работы трёх алгоритмов поиска на разных входных данных:
#
util.plot_search_results_small(
    ('Линейный поиск', search),
    ('Бинарный поиск', binary_search),
    ('Интерполяционный поиск', interpolation_search)
    )
util.plot_search_results_huge(
    ('Бинарный поиск', binary_search),
    ('Интерполяционный поиск', interpolation_search)
    )

# **Вопрос**: что можно сказать об алгоритме интерполяционного поиска? Когда имеет смысл его применять?
# Асимптотически интерполяционный поиск превосходит по своим характеристикам бинарный. Если ключи распределены
# случайным образом, то за один шаг алгоритм уменьшает количество проверяемых элементов с n до n−−√ [1]. То есть,
# после k-ого шага количество проверяемых элементов уменьшается до n12k. Значит, остаётся проверить только 2 элемента
# (и закончить на этом поиск), когда 12k=logn2=1log2n. Из этого вытекает, что количество шагов, а значит, и время
# работы составляет O(loglogn).
#
# При "плохих" исходных данных (например, при экспоненциальном возрастании элементов) время работы может ухудшиться
# до O(n).
#
# Эксперименты показали, что интерполяционный поиск не настолько снижает количество выполняемых сравнений, чтобы
# компенсировать требуемое для дополнительных вычислений время (пока таблица не очень велика). Кроме того, типичные
# таблицы недостаточно случайны, да и разница между значениями loglogn и logn становится значительной только при очень
# больших n. На практике при поиске в больших файлах оказывается выгодным на ранних стадиях применять интерполяционный
# поиск, а затем, когда диапазон существенно уменьшится, переходить к двоичному.
