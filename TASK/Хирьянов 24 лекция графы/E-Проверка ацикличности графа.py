# Дан ориентированный граф. Вершины пронумерованы от 0.
# Трeбуется с помощью обхода в глубину проверить является ли граф ацикличным.
#
# Формат входных данных
# На вход программе в первой строке подаются через пробел два числа: N (2 <= N <= 1000) - число вершин в графе и
# M (1 <= M <= 20000) - число ребер. В следующих M строках задаются ребра, по два числа в каждой строке -
# номера соединенных вершин (соответствующее ребро идет из первой вершины во вторую).
#
# Формат выходных данных
# Требуется распечатать номера вершин, задающих цикл в графе если он существует.
# Номера вершин нужно вывести в порядке следования по циклу. Если циклов несколько вывести любой.
# Если граф ацикличный вывести строку "YES" без кавычек.

# _____________________*** 16 из 34 тестов. Варина реализация ***_____________________

N,M = [int(x) for x in input().split()]
G = {x: set() for x in range(N)}
for i in range (M):
    v1,v2 = map(int, input().split())
    G[v1].add(v2)
#
# # в массиве хранятся цвета 0 = серый, еще не посетили, 1 = белый, только пришли, 2 = черный, уже обработали и ушли
# Color = [0] * N
# # массив в котором храним предков, т.е. путь
# path = []
#
# def dfs(start):
#     # когда мы пришли в вершину мы ее перекрашиваем в белый
#     Color[start] = 1
#     # смотрим всех ее соседей. Если соседей нет, после цикла for идет перекрашивание вершины в черный
#     for u in G[start]:
#         # если мы еще не были в вершине (=0) или ее уже обработали(=2). Последнее нужно, так как при обнаружении
#         # нескольких циклов черная вершина будет пропускаться, т.е. чтобы зафиксировать все циклы
#         if Color[u] == 0:
#             # записываем откуда мы пришли
#             path.append(start)
#             # и запускаем для соседа DFS
#             dfs(u)
#         # если мы уже были в этой вершине(=1), значит мы нашли цикл
#         elif Color[u] == 1:
#             # как и в пред.if надо внести предка в список
#             path.append(start)
#             # если наш сосед, в которого мы собирались идти является стартом(=первый в списке предков),
#             # так как иначе у наших циклов могут появиться хвосты, например когда стартом явл. третий в списке
#             # if path[0] == u поменяла т.к. цикл с хвостом не обнаруживался
#             if u in path:
#                 # print(path)
#                 # печатаем наш список предков
#                 x =path[u:]
#                 print(*x, sep=' ')
#                 exit()
#             # else:
#             #     print('u=', u, 'start=', start)
#         # когда мы обработали вершину чистим список предков, т.е. эта вершина не в цикле
#         # x = path.pop()
#     # мы вершину полностью обработали, перекрашиваем ее в черный
#     Color[start] = 2
#
#
# for i in range(N):
#     if Color[i] == 0:
#         dfs(i)
# print('YES')
def dfs(vertex, G, color, cycle):
    color[vertex] = 1
    for neib in G[vertex]:
        if color[neib] == 0:
            cycle.append(vertex)
            dfs(neib, G, color, cycle)
        elif color[neib] == 1:
            cycle.append(vertex)
            print(cycle)
            exit()
    color[vertex] = 2


color = [0] * N
cycle = []
for vertex in G:
    if color[vertex] == 0:
        dfs(vertex, G, color, cycle)
print(cycle)
print(color)



