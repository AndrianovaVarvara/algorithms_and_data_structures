# Генерирующий алгоритм
def gen_alg(base = 7): # выбираем систему счисления
    x = int(input())
    while x > 0:
        digit = x % base # добыли полседнюю цифру
        print(digit, end = " ")
        x //= base # зачеркнуть последнюю цифру

# Пример чистой функции. Нормальная фукция всю информацию о своих задачах получает из параметров
def max2 (x, y):
    if x > y:
        return x
    return y

def max3 (x, y, z):
    return max2(x, max2(y, z)) # ретурн возвращает значение и прекращает работу функции

# В питоне правило "Утиный полиморфизм" Duck typing. При описании функции типы не указываются, Например, функция max2 может сравнивать все что сравнивается, ограничений доплолнительных
# в языке нет

# Стек вызовов, 'Call stack': А позвала функцию B и ждет, B позвала С и ждет = Стр-ра данных в памяти, куда набрасываются адреса возрата. Адрес возврата - функция (например, main), 
# строка FILO м.б. переполнение стека

# Проектирование программ - структурное программирование. Важно: проектирование сверху-вниз
# mock-функция (пустышка, заглушка, заготовка) = Функция с pass

# Метод Грубой силы - Brute force - Решение принадлежит некоторому множеству решений. = Перебор всех возможных ответов. 
# Например, тест Простоты числа
def is_simple_number (x):
    """определяет, является ли число простым; х - целое полжительное число; если простое, то возвращает True, а иначе - False"""
    divisor = 2
    while divisor < x:
        if x % divisor == 0:
            return False
        divisor += 1
    return True

# help (is_simple_number) = выведет документ строку

# Или например, алгоритм факторизации (разложение на множители)
def factorize_number (x):
    """Раскладывает число на множители и печатает их на экран. Х - целое полжительное число"""
    divisor = 2
    while x > 1:
        if x % divisor == 0:
            print(divisor)
            x //= divisor
        divisor += 1

# Линейный поиск в массиве
def array_search (A: list, N: int, x: int):
    """осуществляет поиск числа х в массиве А от 0 до N-1 индекса включительно. Возвращает индекс элемента х в массиве А. Или -1 если такого нет. Если несколько - индекс первого"""
    for k in range (N):
        if A[k] == x:
            return k
        return -1
# tests
def test_array_search():
    A1 = [1, 2, 3, 4, 5]
    m = array_search (A1, 5, 8)
    if m == -1:
        print ('#test1-ok')
    else:
        print('#test1-fail')

    A2 = [1, 2, 3, 4, 5]
    m = array_search (A2, 5, 2)
    if m == 0:
        print ('#test2-ok')
    else:
        print('#test2-fail')

    A3 = [10, 20, 30, 10, 10]
    m = array_search (A3, 5, 10)
    if m == 0:
        print ('#test3-ok')
    else:
        print('#test3-fail')

# Алгоритм обращения массива
def ivert_array (A: list, N: int):
    """Обращение массива (поворот задом-наперед) в рамках индексов от 0 до N-1"""
    for k in range (N // 2):
        A[k], A[N- 1 - k] == A[N- 1 - k], A[k]

# Циклический сдвиг в массиве. Левый проще чем правый
def left_shift (A, N):
    tmp = A[0] # отложили в сторону
    for k in range (N-1):
        A[k] = A[k+1]
    A[N-1] = tmp    

def right_shift (A, N):
    tmp = A[N-1] # пойдем в обратном порядке
    for k in range (N-2, -1, -1):
        A[k+1] = A[k]
    A[0] = tmp

# Решето Эратосфена
def eratosphen (N):
    """N - конечное число в пределах которого мы ищем все простые числа. По умолчанию все простые = True"""
    A = [True] * N
    A[0] = A[1] = False
    for k in range (2, N):
        if A[k]: # A[k] является простым числом
            for m in range (2*k, N, k):
                A[m] = False
    for k in range (N):
        print(k, '-', 'простое' if A[k] else 'составное')

# List comprehesion Массив с фиксированным = статический массив - размером мы сами смотрим уровень заполнения. Переменная которая показывает уровень заполнения. 
# Встроенные методы рассширения = append, понижение len(A) = pop(). 
# List это объект, изменяемый
def list():
    A = [x**2 for x in range(10)]
    B = [x**2 for x in A if x % 2== 0]


### Квадратичные сортировки O(N2). Асимптотика - память или  скорость вычисления = сколько операций требуется
___________________________________________________________________________________________________________________________________________________________________________________
# Сортировка вставками (INSERT SORT). Вставляем в уже отсортированный массив. Самый первый уже отсортирован, и расширяемся... Инвариант = кусок массива где все стоят упорядочено
def insert_sort (A):
    """вставка"""
    N = len(A)
    for top in range(1, N):
        k = top # top - это верхушечка, эл-т который вставляем начиная со второго элемента
        while k > 0 and A[k-1] > A[k]: # пока тот кого держат за шкирку не является самым левым, пока не ноль И когда тот кто левее выше того кого я вставляю. Логическое И зд.не дает нам выйти за границы массива.
        # ведь питон вычислит к=0 и не будет вычислять А[k-1]
            A[k], A[k-1] = A[k-1], A[k] # я смотрю на тех кто слева и осуществляю сдвиг на лево
            k -= 1 # отслеживаем где он сейчас

# Сортировка методом выбора (CHOISE SORT). Не хочет двигать уже отсортированных. На первой позиции самый минимальный (Поиск минимума/максимума). Назначаем первой позиции текущий минимум, и смотрим других, 
# если нашли меньше, меняем их местами. Инвариант =  изначально размер окончательно упорядоченного массива = 0. След.позиция объявляется вакантной. Последнего сортировать не надо
def choise_sort (A):
    """выбор"""
    N = len(A)
    for pos in range (0, N-1): # начиная с нуля до  N-1  будет отсортирован автоматически
        for k in range (pos+1, N): # 
            if A[k] < A[pos]:
                A[k], A[pos] = A[pos], A[k]
# Сортировка методом пузырька (BUBLE SORT)
def buble_sort (A): # Смотрит двух соседей, и если неправильно стоят - меняет. Инвариант = самый высокий выйдет в конец, отсортированный массив начинается с конца.
    """пузырек"""
    N = len(A)
    for bypass in range (1, N): # считаем количество проходов, с единички чтобы не ходить в хвост
        for k in range (0, N-bypass): # чтоб не выйти за рамки массива до конца не доходим
            if A[k] > A[k+1]: # если тот кто левее выше - меняемся
                A[k], A[k+1] = A[k+1], A[k]

def test_sort (sort_algorithm):
    print ("Тестируем: ", sort_algorithm.__doc__)
    
    print('testcase #1: ', end="")
    A = [4, 2, 5, 1, 3]
    A_sorted = [1, 2, 3, 4, 5]
    sort_algorithm(A)
    print('ok' if A == A_sorted else 'Fail') # поэлементное сравнение двух массивов это len(A) операций

    print('testcase #2: ', end="")
    A = list(range(10, 20)) + list(range(0,10))
    A_sorted = list(range(20))
    sort_algorithm(A)
    print('ok' if A == A_sorted else 'Fail')

    print('testcase #3: ', end="")
    A = [4, 2, 4, 2, 1]
    A_sorted = [1, 2, 2, 4, 4]
    sort_algorithm(A)
    print('ok' if A == A_sorted else 'Fail')

    # if __name__ == "__main__":
    #     test_sort(insert_sort)
    #     test_sort(choise_sort)
    #     test_sort(buble_sort)

# Сортировка подсчетом. Однопроходный алгоритм. O(N) по скорости O(M) по памяти, где М - количество элементов, зд.не надо запоминать все числа. Область допустимых значений - маленькая, мы их считаем. 
# Массив частот F
def count_sort(A):
    N = len (A)
    F = [0] * N
    # частотный анализ. Можно использовать в шифровании
    for i in range (N):
        x = int(input())
        F[x] += 1
    for digit in range (len(F)):
        print(digit, '=', F[digit])

### РЕКУРСИЯ.
____________________________________________________________________________________________________________________________________________________________________________________ 
# В процессе углубления подзадача проще задачи. 1) Рекурентные и 2) крайний случай, 
# прямой (действия до того как передам управления) и обратный (доделываю что-то когда вернется управление) ход рекурсии, 
# переполнение стека вызовов, уровень вложенности, глубина рекурсии = количество вызовов 
# Вызов функции это вычислительный процесс который запущен.
# Развертывание кортежа: *А == (А[0], A[1])

## Факториал
def factorial(n: int):
    assert n >= 0, "Факториал отрицательного числа не определен"
    if n == 0:
        return 1
    return factorial(n-1) * n

# Алгоритм Евклида - НОД - Grand Common Diviser (gcd)
def gcd (a,b):
    if a == b:
        return a
    elif a > b:
        return gcd (a-b, b)
    else:
        return gcd (a, b-a)

    # def gcd (a,b): return a if b == 0 else gcd (b, a%b)

    # Быстрое возведение в степень. a - больше нуля n - Целое положительное число 
    def pow (a: float, n: int):
        if n == 0:
            return 1
        else:
            return pow(a, n-1) * a
    # Когда степень большая
    def pow2 (a: float, n: int):
        if n == 0:
            return 1
        elif n % 2 == 1: # степень нечетная
            return pow2(a, n-1) * a
        else:
            return pow2(a**2, n//2)
# например возводим 3 в степень 5, для этого делаем первый вызов:
# 1) pow(3, 5)
#     функция получает (3, 5)
#         проверка: 5 == 0 ? нет, значит идем дальше
#         проверка: 5 нечетное? да, значит делается второй (рекурсивный) вызов:
# 2) return pow(3, 4) * 3 - здесь рекурсивный вызов в операторе return pow(a, n-1)*a
#     функция получает (3, 4)
#         проверка: 4 == 0 ? нет, значит идем дальше
#         проверка: 4 нечетное? нет, значит делается третий (рекурсивный) вызов:
# 3) return pow(9, 2) - здесь рекурсивный вызов в операторе return pow(a**2, n//2)
#     функция получает (9, 2)
#         проверка: 2 == 0 ? нет, значит идем дальше
#         проверка: 2 нечетное? нет, значит делается четвертый (рекурсивный) вызов:
# 4) return pow(81, 1) - здесь рекурсивный вызов в операторе return pow(a**2, n//2)
#     функция получает (81, 1)
#         проверка: 1 == 0 ? нет, значит идем дальше
#         проверка: 1 нечетное? да, значит делается пятый (рекурсивный) вызов:
# 5) return pow(81, 0) * 81 - здесь рекурсивный вызов в операторе return pow(a, n-1)*a
#     функция получает (81, 0)
#         проверка: 0 == 0 ? да, значит СТОП дальше не идем, возвращает 1

# ЗДЕСЬ рекурсия останавливается и начинается размотка рекурсивных вызовов обратно

# возврат значения 1 происходит в строку 5), там вычисляется и возвращается 1 * 81 = 81
# возврат значения 81 происходит в строку 4), там это значение сразу возвращается
# возврат значения 81 происходит в строку 3), там это значение сразу возвращается
# возврат значения 81 происходит в строку 2), там вычисляется и возвращается 81 * 3 = 243
# возврат значения 243 происходит в строку 1), это значение является РЕЗУЛЬТАТОМ
# результат 243

## Ханойские башни
# где n - номер диска,  start - номер стержня с которого снимается данный диск,  finish - номер стержня на который надевается данный диск.
def hanoi_towers(n, start, finish):
    if n == 1:
        print("Перенести диск 1 со стержня", start, "на стержень", finish)
    else:
        temp = (6 - start) - finish
        hanoi_towers(n - 1, start, temp)
        print("Перенести диск", n, "со стержня", start, "на стержень", finish)
        res = (n - 1, temp, finish)
        print(res)
 
        return res

## генерация всех перестановок. Комбинаторика n!
def generate_number(N: int, M: int, prefix = None):
    """генерирует все чила с лидирующими незначащимими нулями в N-ричной системе счисления (N <= 10 длины М)"""
    prefix = prefix or []
    if M == 0:
        print(prefix)
        return
    for digit in range(N):
        prefix.append(digit)
        generate_number(N, M-1, prefix)
        prefix.pop()

# 
def find(number, A):
    """Ищет number в A и возвращает True, если такой есть False, если такого нет"""
    for x in A:
        if number == x:
            return True
    return False

def generate_permutations(N, M = -1, prefix = None):
    """Генерация всех перестановк N чисел в М позициях, с префиксом prefix"""
    M = N if M == -1 else M # по умолчанию N чисел в N позициях
    prefix = prefix or []
    if M == 0:
        print(*prefix)
        return
    for number in range(1, N+1):
        if find(number, prefix):
            continue
        prefix.append(number)
        generate_permutations(N, M-1, prefix)
        prefix.pop()


### РЕКУРЕНТНЫЕ СОРТИРОВКИ
__________________________________________________________________________________________________________________________________________________________________________________
# Быстрая Сортировка Тони Хоара W(N*log2N) - не всегда такая хорошая асимптотика. Без доп. памяти. на прямом ходу. 
# АЛГОРИТМ РАЗДЕЛЯЙ И ВЛАСТВУЙ - барьерный элемент,  три кучи (меньше, больше, равно), и запускаем две сортировки для меньшей кучки и для большей. Потом всех соединяем
def hoar_sort(A): # эта реализация кушает доп.память равную размеру массива А
    if len(A) <= 1:
        return
    barrier = A[0] # здесь д.б. случайное число, но в обучающих целях было выбрано первое число
    L =[]
    M = []
    R = []
    for x in A:
        if x < barrier:
            L.append(x)
        elif x == barrier:
            M.append(x)
        else:
            R.append(x)
    k = 0 # уровень заполненности А
    hoar_sort(L)
    hoar_sort(R)
    for x in L + M + R:
        A[k] = x
        k += 1

# Сортировка слиянием O(N*log2N). Нужно О(N) памяти. на обратном ходу.  
# Делим на две части, каждую сортируем, беерм доп.память и сливаем два в один, и записываем самого маленького из одной из половинок, и так перебираем всех.
# УСТОЙЧИВОСТЬ СОРТИРОВКИ - если сортировка не меняет порядок равных элементов
def merge (A:list, B: list):
    """слияние отсортированных массивов в один"""
    C[0] * (len(A) + len(B))
    i = k = n = 0 # каждый индекс для каждого списка, i - для A, k - для B, n - для С
    while i < len(A) and k < len(B) # т.е. пока никто не вышел за границы своих массивов
        if A[i] <= B[k]: # улучшает устойчивость сортировки в сравнении с просто меньше
            C[n] = A[i]
            i += 1
            n += 1
        else:
            C[n] = B[k]
            k += 1
            n += 1
    while i < len(A):
        C[n] = A[i]
        i += 1
        n += 1
    while k < len(B):
        C[n] = B[k]
        k += 1
        n += 1        
    return C
def merge_sort(A):
    """рекурентная функция, еще больше памяти О(М*logN) """
    if len(A) <= 1:
        return
    middle = len(A) // 2
    # можно реализовать через срезы, но здесь через List Comprehencion
    L = [A[i] for i in range (0, middle)]
    R = [A[i] for i in range (middle, len(A))]
    merge_sort(L)
    merge_sort(R)
    C = merge(L, R)
    for i in range (len(A)):
        A[i] = C [i ]

# Проверка упорядоченности массива за О(N) по возр по убыванию будет False
def check_sorted(A, ascending = True):
    flag = True
    s = 2 * int(ascending) - 1
    for i in range (0, N-1): # N-1 чтобы не выйти за границу
        if s*A[i] > s*A[i+1]:
            flag = False
            break
    return flag

# Бинарный поиск в массиве. Левая граница (меньший искомого, не ливее чем -1) и правая граница(больше искомого не больше чем N) показывают место искомого числа в массиве. 
# Алгоритм поиска левой границы и правой разные. ТРЕБОВАНИЕ - МАССИВ Д.Б. ОТСОРТИРОВАН? O(logN)
def left_bound(A, key):
    left = -1 # выставляем границы по краям
    right = len(A)
    while right - left > 1:
        middle = (left + right) // 2 # среляем в середину
        if A[middle] < key:
            left = middle # если меньше, перекидываем левую границу
        else:
            right = middle
    return left

    def right_bound(A, key):
    left = -1 # выставляем границы по краям
    right = len(A)
    while right - left > 1:
        middle = (left + right) // 2 # среляем в середину
        if A[middle] < key:
            left = middle # если меньше, перекидываем левую границу
        else:
            right = middle
    return left

def binarySearch(arr, l=-1, r=len(arr)-1, x): # х - искомое число
    """возвращает индекс х в arr если есть, и -1 если нет"""
    if r >= l:
        mid = l + (r-l) / 2
        if arr[mid] == x:
            return mid
        elif arr[mid] > x:
            return binarySearch(arr, l, mid-1, x)
        else:
            return binarySearch(arr, mid + 1, r, x)
    else:
        return -1    

### Классические задачи для одномерного динамического программирования за O(N) операций
______________________________________________________________________________________________________________________________________________________________________________
# 1. Про кузнечика сколько различных траекторий допрыгать до клетки N? аналогична задаче про фибоначи
def traj_num(N):
    k = [0, 1] + [0] * (N - 1) #  добавляем несуществующий нолик к кот. добраться ноль возможностей, чтобы не было смещения индекса и позиции поэтому N-1 а не -2
    for i in range (2, N + 1):
        k[i] = k[i-2] + k[i-1]
    return k[N]

# 2. запрещенные клетки для посещения 
def count_traj(N, allowed: list): # в allowed булевые значения
    k = [0, 1, int(allowed[2]] + [0] * (N - 2) # добавляем int(allowed[2]) т.к. нам важно запрещенная 3 клетка или нет, 0 - запрещена, 1 - разрешена
    for i in range (3, N + 1):
        if allowed[i]:
            k[i] = k[i-1] + k[i-2] + k[i-3]
    return k[N]

# 3. Минимальная стоимость
def count_min_cost(N, prise:list):
    C = [None, price[1], price[1] + price[2]] + [0]*(N-2)
    for i in range(3, N+1):
        C[i] = price[i] + min(C[i-1. C[i-2]])
        return C(N) # здесь будет стоимость, для того чтобы узнать траекторию надо запоминать откуда пришли

#### Двумерные массивы - в питоне это список списков A = [[0] * M for i in range(N)] ширина массива известна и зафиксирована 
# Задача про короля Сколькими способами король может добраться до клеточки N
def king():
    m = int(input())
    n = int(input())
    k = [[0] * m for i in range(n)]
    for i in range(n):
        k[i][0] = 1
    for j in range(m):
        k[0][j] = 1
    for i in range(1, n):
        for j in range(1, m):
            k[i][j] = k[i-1][j-1] + k[i-1][j] + k[i][j-1]
    print(k[n-1][m-1])

# Алгоритм укладки рюкзака


# Наибольшая общая подпоследовательность Longest common subsicvens
def lcs():
    pass

# Наибольшая возрастающая подпоследовательность 
def gis():
    pass

# Вычисление редакционного расстояния между строками = расстояние Левинштейна
def levenstein():
    pass

# проверка равенства строк
def equal():
    pass

# Поиск подстроки в строке + ПРЕФИКС ФУНКЦИЯ. Алгоритм Кнута Мориса Пратта
def search_substring():
    pass

### СТРУКТУРЫ ДАННЫХ
________________________________________________________________________________________________________________________________________________________________________________
## СТЕК push, pop, ckear, is_empty
# Проверка корректности скобочной последовательности
def brace():
    pass
# Обратная польская нотация
def brace():
    pass

## КУЧА макс и мин для сортировки хороша

## Связный список. 

# Линейный однонаправленный список — это структура данных, состоящая из элементов одного типа, связанных между собой последовательно посредством указателей. 
# Каждый элемент списка имеет указатель на следующий элемент. Последний элемент списка указывает на NULL. Элемент, на который нет указателя, является первым (головным) 
# элементом списка. Здесь ссылка в каждом узле указывает на следующий узел в списке. В односвязном списке можно передвигаться только в сторону конца списка. 
# Узнать адрес предыдущего элемента, опираясь на содержимое текущего узла, невозможно.

# Двусвязный список (двунаправленный связный список) - Здесь ссылки в каждом узле указывают на предыдущий и на последующий узел в списке. Как и односвязный список, 
# двусвязный допускает только последовательный доступ к элементам, но при этом дает возможность перемещения в обе стороны. 
# В этом списке проще производить удаление и перестановку элементов, так как легко доступны адреса тех элементов списка, указатели которых направлены на изменяемый элемент.

## Хэш таблицы - это структура данных, реализующая интерфейс ассоциативного массива, а именно, она позволяет хранить пары (ключ, значение) и выполнять три операции: 
# операцию добавления новой пары, операцию поиска и операцию удаления пары по ключу. Существуют два основных варианта хеш-таблиц: с цепочками и открытой адресацией. 
# Хеш-таблица содержит некоторый массив {\displaystyle H}H, элементы которого есть пары (хеш-таблица с открытой адресацией) или списки пар (хеш-таблица с цепочками). 
# Выполнение операции в хеш-таблице начинается с вычисления хеш-функции от ключа. Получающееся хеш-значение i = hash(key) играет роль индекса в массиве H. 
# Затем выполняемая операция (добавление, удаление или поиск) перенаправляется объекту, который хранится в соответствующей ячейке массива H[i]. 
# Ситуация, когда для различных ключей получается одно и то же хеш-значение, называется коллизией.


### ООП
________________________________________________________________________________________________________________________________________________________________________________
## Классы и объекты = тип и значение


### Графы
________________________________________________________________________________________________________________________________________________________________________________
## Обход в глубину
## Обход в ширину
## Эйлеров цикл
## Гамильтонов цикл 